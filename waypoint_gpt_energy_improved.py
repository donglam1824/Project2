import logging
import math

def read_map_from_file(filename):
    map_data = []
    with open(filename, 'r') as file:
        for line in file:
            row = line.strip().split()
            map_data.append(row)
    return map_data

directions_4 = [(-1, 0), (1, 0), (0, -1), (0, 1)]

def is_adjacent(pos1, pos2):
    """Ki·ªÉm tra hai ƒëi·ªÉm c√≥ li·ªÅn k·ªÅ nhau kh√¥ng (ch·ªâ c√°ch nhau 1 √¥ theo 4 h∆∞·ªõng)"""
    return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1]) == 1

def find_charging_stations(map_data):
    """T√¨m t·∫•t c·∫£ c√°c tr·∫°m s·∫°c (ƒëi·ªÉm c√≥ gi√° tr·ªã 2) trong b·∫£n ƒë·ªì"""
    charging_stations = []
    rows, cols = len(map_data), len(map_data[0])
    
    for i in range(rows):
        for j in range(cols):
            if map_data[i][j] == '2':
                charging_stations.append((i, j))
    
    return charging_stations

def manhattan_distance(pos1, pos2):
    """T√≠nh kho·∫£ng c√°ch Manhattan gi·ªØa hai ƒëi·ªÉm"""
    return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])

def find_nearest_charging_station(current_pos, charging_stations):
    """T√¨m tr·∫°m s·∫°c g·∫ßn nh·∫•t t·ª´ v·ªã tr√≠ hi·ªán t·∫°i"""
    if not charging_stations:
        return None
    
    return min(charging_stations, key=lambda station: manhattan_distance(current_pos, station))

def bfs_path_safe(map_data, start, goal):
    """BFS an to√†n - ch·ªâ di chuy·ªÉn qua √¥ tr·ªëng (0) v√† tr·∫°m s·∫°c (2), tr√°nh ch∆∞·ªõng ng·∫°i v·∫≠t (1)"""
    if start == goal:
        return [start]
    
    rows, cols = len(map_data), len(map_data[0])
    queue = [(start, [start])]
    visited = set([start])
    
    while queue:
        (x, y), path = queue.pop(0)
        
        if (x, y) == goal:
            return path
        
        # Ki·ªÉm tra 4 h∆∞·ªõng di chuy·ªÉn
        for dx, dy in directions_4:
            nx, ny = x + dx, y + dy
            
            # Ki·ªÉm tra t√≠nh h·ª£p l·ªá: trong bi√™n, kh√¥ng ph·∫£i ch∆∞·ªõng ng·∫°i v·∫≠t, ch∆∞a thƒÉm
            if (0 <= nx < rows and 0 <= ny < cols and 
                map_data[nx][ny] in ['0', '2'] and  # CH·ªà ƒëi qua √¥ tr·ªëng v√† tr·∫°m s·∫°c
                (nx, ny) not in visited and
                is_adjacent((x, y), (nx, ny))):  # ƒê·∫£m b·∫£o di chuy·ªÉn t·ª´ng b∆∞·ªõc
                
                visited.add((nx, ny))
                new_path = path + [(nx, ny)]
                queue.append(((nx, ny), new_path))
    
    return []  # Kh√¥ng t√¨m ƒë∆∞·ª£c ƒë∆∞·ªùng

def validate_path_continuity(path):
    """Ki·ªÉm tra t√≠nh li√™n t·ª•c c·ªßa ƒë∆∞·ªùng ƒëi (m·ªói b∆∞·ªõc ch·ªâ c√°ch 1 √¥)"""
    if len(path) < 2:
        return True
    
    for i in range(1, len(path)):
        if not is_adjacent(path[i-1], path[i]):
            print(f"‚ùå Path discontinuity: {path[i-1]} -> {path[i]}")
            return False
    return True

def get_all_empty_cells(map_data):
    """L·∫•y t·∫•t c·∫£ c√°c √¥ tr·ªëng c√≥ th·ªÉ di chuy·ªÉn ƒë∆∞·ª£c"""
    empty_cells = []
    rows, cols = len(map_data), len(map_data[0])
    
    for i in range(rows):
        for j in range(cols):
            if map_data[i][j] in ['0', '2']:  # √î tr·ªëng ho·∫∑c tr·∫°m s·∫°c
                empty_cells.append((i, j))
    
    return empty_cells

def get_next_closest_unvisited_cell(current_pos, all_cells, visited):
    """T√¨m √¥ ch∆∞a thƒÉm g·∫ßn nh·∫•t t·ª´ v·ªã tr√≠ hi·ªán t·∫°i"""
    unvisited = [cell for cell in all_cells if cell not in visited]
    
    if not unvisited:
        return None
    
    return min(unvisited, key=lambda cell: manhattan_distance(current_pos, cell))

class EnergyManager:
    """Qu·∫£n l√Ω nƒÉng l∆∞·ª£ng c·ªßa robot"""
    
    def __init__(self, max_energy, map_data):
        self.max_energy = max_energy
        self.current_energy = max_energy
        self.map_data = map_data
        self.charging_stations = find_charging_stations(map_data)
        self.energy_log = []
        
        print(f"üîã Kh·ªüi t·∫°o EnergyManager v·ªõi nƒÉng l∆∞·ª£ng t·ªëi ƒëa: {max_energy}")
        print(f"‚ö° T√¨m th·∫•y {len(self.charging_stations)} tr·∫°m s·∫°c t·∫°i: {self.charging_stations}")
    
    def consume_energy(self, amount=1):
        """Ti√™u th·ª• nƒÉng l∆∞·ª£ng"""
        self.current_energy = max(0, self.current_energy - amount)
    
    def charge_full(self):
        """S·∫°c ƒë·∫ßy nƒÉng l∆∞·ª£ng"""
        old_energy = self.current_energy
        self.current_energy = self.max_energy
        print(f"üîã Robot ƒë√£ s·∫°c ƒë·∫ßy: {old_energy} -> {self.current_energy}")
    
    def find_reachable_charging_station(self, current_pos):
        """T√¨m tr·∫°m s·∫°c c√≥ th·ªÉ ƒë·∫øn ƒë∆∞·ª£c v·ªõi nƒÉng l∆∞·ª£ng hi·ªán t·∫°i"""
        reachable_stations = []
        for station in self.charging_stations:
            distance = manhattan_distance(current_pos, station)
            if distance <= self.current_energy:
                reachable_stations.append((station, distance))
        
        if reachable_stations:
            # S·∫Øp x·∫øp theo kho·∫£ng c√°ch g·∫ßn nh·∫•t
            reachable_stations.sort(key=lambda x: x[1])
            return reachable_stations[0][0]  # Tr·∫£ v·ªÅ tr·∫°m g·∫ßn nh·∫•t
        
        return None

def smart_coverage_with_energy_management(map_data, max_energy=400, low_energy_threshold=50):
    """Thu·∫≠t to√°n d·ªçn d·∫πp th√¥ng minh v·ªõi qu·∫£n l√Ω nƒÉng l∆∞·ª£ng real-time"""
    
    energy_manager = EnergyManager(max_energy, map_data)
    
    # L·∫•y t·∫•t c·∫£ c√°c √¥ c·∫ßn d·ªçn d·∫πp
    all_cells = get_all_empty_cells(map_data)
    visited = set()
    waypoints = []
    
    print(f"üè† T·ªïng s·ªë √¥ c·∫ßn d·ªçn d·∫πp: {len(all_cells)}")
    print(f"üöÄ B·∫Øt ƒë·∫ßu t·ª´ g√≥c tr√™n tr√°i...")
    
    # T√¨m ƒëi·ªÉm b·∫Øt ƒë·∫ßu (g√≥c tr√™n tr√°i)
    current_pos = min(all_cells, key=lambda p: p[0] * 1000 + p[1])
    waypoints.append(current_pos)
    visited.add(current_pos)
    
    print(f"üìç ƒêi·ªÉm b·∫Øt ƒë·∫ßu: {current_pos}")
    
    # Thu·∫≠t to√°n coverage v·ªõi qu·∫£n l√Ω nƒÉng l∆∞·ª£ng real-time
    while len(visited) < len(all_cells):
        
        # T√¨m √¥ ti·∫øp theo c·∫ßn thƒÉm
        next_cell = get_next_closest_unvisited_cell(current_pos, all_cells, visited)
        
        if not next_cell:
            print("‚úÖ ƒê√£ ho√†n th√†nh t·∫•t c·∫£ c√°c √¥!")
            break
        
        # T√≠nh kho·∫£ng c√°ch ƒë·∫øn √¥ ti·∫øp theo
        distance_to_next = manhattan_distance(current_pos, next_cell)
        
        # T√¨m tr·∫°m s·∫°c g·∫ßn nh·∫•t t·ª´ next_cell ƒë·ªÉ ƒë√°nh gi√°
        nearest_station = find_nearest_charging_station(next_cell, energy_manager.charging_stations)
        distance_to_station = manhattan_distance(next_cell, nearest_station) if nearest_station else float('inf')
        
        # Ki·ªÉm tra nƒÉng l∆∞·ª£ng: c·∫ßn ƒë·ªß ƒë·ªÉ ƒë·∫øn √¥ ti·∫øp theo + quay v·ªÅ tr·∫°m s·∫°c + buffer
        energy_needed = distance_to_next + distance_to_station + 20  # Buffer 20
        
        # N·∫øu nƒÉng l∆∞·ª£ng kh√¥ng ƒë·ªß, ƒëi s·∫°c tr∆∞·ªõc
        if energy_manager.current_energy < energy_needed:
            print(f"üîã NƒÉng l∆∞·ª£ng th·∫•p ({energy_manager.current_energy}), c·∫ßn ƒëi s·∫°c!")
            
            reachable_station = energy_manager.find_reachable_charging_station(current_pos)
            
            if reachable_station:
                print(f"üéØ ƒêi ƒë·∫øn tr·∫°m s·∫°c: {reachable_station}")
                
                # T√¨m ƒë∆∞·ªùng ƒë·∫øn tr·∫°m s·∫°c
                path_to_station = bfs_path_safe(map_data, current_pos, reachable_station)
                
                if path_to_station and len(path_to_station) <= energy_manager.current_energy:
                    # Di chuy·ªÉn ƒë·∫øn tr·∫°m s·∫°c
                    for point in path_to_station[1:]:  # B·ªè qua ƒëi·ªÉm hi·ªán t·∫°i
                        waypoints.append(point)
                        energy_manager.consume_energy(1)
                        
                        if energy_manager.current_energy <= 0:
                            print("‚ùå H·∫øt nƒÉng l∆∞·ª£ng!")
                            return waypoints
                    
                    current_pos = reachable_station
                    energy_manager.charge_full()
                else:
                    print("‚ùå Kh√¥ng th·ªÉ ƒë·∫øn tr·∫°m s·∫°c!")
                    break
            else:
                print("‚ùå Kh√¥ng c√≥ tr·∫°m s·∫°c n√†o trong t·∫ßm v·ªõi!")
                break
        
        # Di chuy·ªÉn ƒë·∫øn √¥ ti·∫øp theo
        path_to_next = bfs_path_safe(map_data, current_pos, next_cell)
        
        if path_to_next:
            # Th√™m ƒë∆∞·ªùng ƒëi v√†o waypoints
            for point in path_to_next[1:]:  # B·ªè qua ƒëi·ªÉm hi·ªán t·∫°i
                if point not in visited:  # Ch·ªâ th√™m √¥ ch∆∞a thƒÉm
                    waypoints.append(point)
                    visited.add(point)
                    energy_manager.consume_energy(1)
                    
                    # Ki·ªÉm tra nƒÉng l∆∞·ª£ng trong qu√° tr√¨nh di chuy·ªÉn
                    if energy_manager.current_energy <= 0:
                        print("‚ùå H·∫øt nƒÉng l∆∞·ª£ng!")
                        return waypoints
            
            current_pos = path_to_next[-1]
            
            # C·∫≠p nh·∫≠t progress
            coverage_percent = (len(visited) / len(all_cells)) * 100
            print(f"üßπ Progress: {len(visited)}/{len(all_cells)} ({coverage_percent:.1f}%) - Energy: {energy_manager.current_energy}")
            
        else:
            print(f"‚ùå Kh√¥ng t√¨m ƒë∆∞·ª£c ƒë∆∞·ªùng ƒë·∫øn {next_cell}")
            # Lo·∫°i b·ªè √¥ n√†y kh·ªèi danh s√°ch
            all_cells.remove(next_cell)
    
    print(f"üéâ Ho√†n th√†nh! Coverage: {len(visited)}/{len(all_cells)} √¥")
    print(f"‚ö° NƒÉng l∆∞·ª£ng c√≤n l·∫°i: {energy_manager.current_energy}/{energy_manager.max_energy}")
    print(f"üìä T·ªïng waypoints: {len(waypoints)}")
    
    return waypoints

def validate_waypoints_safety(waypoints, map_data):
    """Ki·ªÉm tra t√≠nh an to√†n c·ªßa c√°c waypoints"""
    safe_waypoints = []
    unsafe_count = 0
    
    for i, (row, col) in enumerate(waypoints):
        if 0 <= row < len(map_data) and 0 <= col < len(map_data[0]):
            if map_data[row][col] in ['0', '2']:  # √î tr·ªëng ho·∫∑c tr·∫°m s·∫°c
                safe_waypoints.append((row, col))
            else:  # Ch∆∞·ªõng ng·∫°i v·∫≠t
                unsafe_count += 1
                print(f"‚ö†Ô∏è  Waypoint {i}: ({row}, {col}) ƒëi v√†o ch∆∞·ªõng ng·∫°i v·∫≠t!")
        else:
            unsafe_count += 1
            print(f"‚ö†Ô∏è  Waypoint {i}: ({row}, {col}) ngo√†i bi√™n b·∫£n ƒë·ªì!")
    
    print(f"üîç Ki·ªÉm tra an to√†n: {len(safe_waypoints)}/{len(waypoints)} waypoints an to√†n")
    if unsafe_count > 0:
        print(f"‚ùå T√¨m th·∫•y {unsafe_count} waypoints kh√¥ng an to√†n!")
    
    return safe_waypoints

def write_waypoints_to_file(waypoints, filename):
    """Ghi waypoints v√†o file"""
    with open(filename, 'w') as file:
        for point in waypoints:
            file.write(f"({point[0]}, {point[1]})\n")
    print(f"‚úÖ ƒê√£ ghi {len(waypoints)} waypoints v√†o {filename}")

def remove_duplicate_consecutive_points(waypoints):
    """Lo·∫°i b·ªè c√°c ƒëi·ªÉm tr√πng l·∫∑p li√™n ti·∫øp"""
    if not waypoints:
        return []
    
    result = [waypoints[0]]
    for i in range(1, len(waypoints)):
        if waypoints[i] != waypoints[i-1]:
            result.append(waypoints[i])
    
    return result

def main():
    map_data = read_map_from_file('apartment_map.txt')
    print(f"üìã ƒê√£ ƒë·ªçc b·∫£n ƒë·ªì k√≠ch th∆∞·ªõc: {len(map_data)}x{len(map_data[0])}")
    
    # Thi·∫øt l·∫≠p nƒÉng l∆∞·ª£ng
    MAX_ENERGY = 400
    LOW_ENERGY_THRESHOLD = 50
    
    print(f"ü§ñ Kh·ªüi ƒë·ªông robot v·ªõi nƒÉng l∆∞·ª£ng t·ªëi ƒëa: {MAX_ENERGY}")
    print(f"‚ö†Ô∏è  Ng∆∞·ª°ng c·∫£nh b√°o nƒÉng l∆∞·ª£ng th·∫•p: {LOW_ENERGY_THRESHOLD}")
    
    # Ch·∫°y thu·∫≠t to√°n d·ªçn d·∫πp th√¥ng minh
    waypoints = smart_coverage_with_energy_management(
        map_data, 
        max_energy=MAX_ENERGY, 
        low_energy_threshold=LOW_ENERGY_THRESHOLD
    )
    
    # Lo·∫°i b·ªè duplicate
    waypoints = remove_duplicate_consecutive_points(waypoints)
    
    # Ki·ªÉm tra t√≠nh an to√†n
    safe_waypoints = validate_waypoints_safety(waypoints, map_data)
    
    if len(safe_waypoints) != len(waypoints):
        print(f"‚ö†Ô∏è  C·∫£nh b√°o: {len(waypoints) - len(safe_waypoints)} waypoints kh√¥ng an to√†n ƒë√£ b·ªã lo·∫°i b·ªè!")
        waypoints = safe_waypoints
    
    # Ki·ªÉm tra t√≠nh li√™n t·ª•c
    if validate_path_continuity(waypoints):
        print("‚úÖ ƒê∆∞·ªùng ƒëi li√™n t·ª•c")
    else:
        print("‚ùå C·∫£nh b√°o: ƒê∆∞·ªùng ƒëi kh√¥ng li√™n t·ª•c!")
    
    # Ghi file
    write_waypoints_to_file(waypoints, 'waypoint_gpt_energy_improved.txt')
    
    print("üéØ Ho√†n th√†nh!")

if __name__ == "__main__":
    main()
